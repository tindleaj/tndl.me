<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="apple-mobile-web-app-capable"
        content="yes">
  <meta name="viewport"
        content="width=device-width, initial-scale=1">
  <meta name="description"
        content="">
  <meta name="author"
        content="">
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono|Fira+Sans"
        rel="stylesheet">
  <link href="http:&#x2F;&#x2F;127.0.0.1:1111/site.css"
        rel="stylesheet">

  <title>Writing a simple command line program in Rust</title>
</head>

<body id="blog">
  <section class="markdown">
    <h1 id="writing-a-simple-command-line-program-in-rust">Writing a simple command line program in Rust</h1>
<p><em>A JavaScript developer's guide to the Rust programming language</em></p>
<ul>
<li><a href="http://127.0.0.1:1111/blog/wc/#writing-a-simple-command-line-program-in-rust">Writing a simple command line program in Rust</a>
<ul>
<li><a href="http://127.0.0.1:1111/blog/wc/#introduction">Introduction</a></li>
<li><a href="http://127.0.0.1:1111/blog/wc/#setting-up">Setting up</a>
<ul>
<li><a href="http://127.0.0.1:1111/blog/wc/#project-structure">Project structure</a></li>
<li><a href="http://127.0.0.1:1111/blog/wc/#running-the-project">Running the project</a></li>
<li><a href="http://127.0.0.1:1111/blog/wc/#tour-of-a-quothello-worldquot-program-in-rust">Tour of a &quot;Hello World&quot; program in Rust</a></li>
</ul>
</li>
<li><a href="http://127.0.0.1:1111/blog/wc/#the-miniwc-program">The miniwc program</a>
<ul>
<li><a href="http://127.0.0.1:1111/blog/wc/#building-a-foundation">Building a foundation</a>
<ul>
<li><a href="http://127.0.0.1:1111/blog/wc/#types">Types</a></li>
<li><a href="http://127.0.0.1:1111/blog/wc/#structures-struct">Structures (struct)</a></li>
<li><a href="http://127.0.0.1:1111/blog/wc/#implementations-impl">Implementations (impl)</a></li>
</ul>
</li>
<li><a href="http://127.0.0.1:1111/blog/wc/#handling-arguments">Handling arguments</a>
<ul>
<li><a href="http://127.0.0.1:1111/blog/wc/#the-iterator-trait">The Iterator trait</a></li>
<li><a href="http://127.0.0.1:1111/blog/wc/#storing-things-in-vectors">Storing things in Vectors</a></li>
<li><a href="http://127.0.0.1:1111/blog/wc/#the-panic-macro">The panic! macro</a></li>
</ul>
</li>
<li><a href="http://127.0.0.1:1111/blog/wc/#the-filesystem">The filesystem</a>
<ul>
<li><a href="http://127.0.0.1:1111/blog/wc/#handling-possible-failure-with-expect">Handling possible failure with expect</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>In this article we will build a simple command line program that returns the word count of a file. This will essentially be a simpler version of the Unix utility <code>wc</code>, written in Rust. The goal of this article is to give an introduction to some core Rust concepts for readers who might be more familiar with web languages such as JavaScript and Typescript. Therefore, the Rust code examples will be compared to similar code and concepts in JavaScrip or TypeScript. This guide also assumes no prior knowledge of Rust or related tools, but it does assume you have <code>node</code> and <code>npm</code> installed on your machine already.</p>
<p>A couple of notes and assumptions:</p>
<ul>
<li>No previous knowledge of Rust is assumed. We'll go over all of the necessary concepts as they come up, and I'll link to relevant content where I think more detail or rigor is needed.</li>
<li>Roughly intermediate-level experience with JavaScript is assumed. If you're just getting started with JavaScript or haven't built anything non-trivial with it, you might want to save this resource for later.</li>
</ul>
<h2 id="setting-up">Setting up</h2>
<p>In order to get started, first we need to set up a new Rust project. If you haven't yet installed Rust on your computer, you can take a look at <a href="https://www.rust-lang.org/learn/get-started">the official 'getting started' guide</a>.</p>
<p>Once you have <code>cargo</code> available, go ahead and run <code>cargo new miniwc --bin</code> in a suitable directory.</p>
<h3 id="project-structure">Project structure</h3>
<p>You might now be asking, 'What is <code>cargo</code>? For those new to Rust's tooling, <code>cargo</code> is a direct parallel to <code>npm</code> in the Node ecosystem, in other words Rust's built-in package manager. You can view popular <code>crates</code> (packages) available at <a href="https://crates.io">crates.io</a>.</p>
<p>The <code>cargo new miniwc --bin</code> command tells <code>cargo</code> to create a new <em>binary</em> (able to run on our machine) Rust project named <code>miniwc</code> in the directory <code>./miniwc</code> and set up the basic boilerplate project structure: <code>Cargo.toml</code>, <code>src/main.rs</code>, and a <code>.gitignore</code>.</p>
<ul>
<li><code>Cargo.toml</code>: Analogous to Node's <code>package.json</code>. This is where you put project information and declare project dependencies</li>
<li><code>Cargo.lock</code>: This is a manifest managed by <code>cargo</code>, that tracks exact dependency versions. It is analogous to Node's <code>package-lock.json</code>.</li>
<li><code>src/main.rs</code>: Our project is a <em>binary</em> project, meaning we can compile and run it on our machine. <code>cargo</code> creates a <code>main.rs</code> file as the default entry point for compiling our source code.</li>
<li><code>.gitignore</code>: A standard <code>git</code> artifact, tells <code>git</code> what files to ignore from source control.</li>
</ul>
<h3 id="running-the-project">Running the project</h3>
<p>That's it for the project structure, but what about actually running the code? In <code>node</code>, we have <code>npm</code> which allows us to define scripts such as <code>start</code> and <code>test</code>, and then run those commands via <code>npm run start</code> or <code>npm run test</code>. <code>cargo</code> gives us similar functionality. Running <code>cargo run</code> in our project directory will run our boilerplate project. Try it out, and you should see <code>Hello, world!</code> printed to your console.</p>
<blockquote>
<p>You may have noticed a new <code>target/</code> directory appear after you ran <code>cargo run</code>. This is a folder managed by <code>cargo</code> to store build artifacts and other dependencies of the compilation process. For a more detailed guide to <code>cargo</code> and an overview of concepts like the <code>target/</code> directory, check out <a href="https://doc.rust-lang.org/cargo/index.html">The Cargo Book</a>.</p>
</blockquote>
<h3 id="tour-of-a-hello-world-program-in-rust">Tour of a &quot;Hello World&quot; program in Rust</h3>
<p>Let's take a moment to take a look at the auto-generated code within <code>main.rs</code> and draw some basic parallels from the JavaScript world to that of Rust:</p>
<p>Filename: src/main.rs</p>
<pre style="background-color:#ffffff;">
<span style="color:#202020;">fn main() {
    println!(</span><span style="color:#707070;">&quot;Hello, world!&quot;</span><span style="color:#202020;">);
}
</span></pre>
<p>If we ported the above Rust program to JavaScript it would look like:</p>
<pre style="background-color:#ffffff;">
<span style="color:#202020;">function main() {
  console.log(</span><span style="color:#707070;">&#39;Hello, world!&#39;</span><span style="color:#202020;">)
}

</span><span style="color:#bbbbbb;">// Since `main()` isn&#39;t a special function in JavaScript,
// we have to invoke it if we want our code to run:
</span><span style="color:#202020;">main()
</span></pre>
<p><em>If the distinction between compiled and interpreted languages is a bit hazy for you, take a look at <a href="https://guide.freecodecamp.org/computer-science/compiled-versus-interpreted-languages/">this article</a> for a more in-depth treatment.</em></p>
<p><code>fn</code> is the <em>function</em> keyword in Rust, and <code>main</code> denotes to the name of the function. <code>main</code> is a special function name in Rust (as it is in other compiled languages like C) and it lets the Rust <em>compiler</em> know that this is the entry point of an executable program. <code>()</code> is the list of <em>arguments</em>. In this case there are no arguments, so the parentheses are empty.</p>
<p>The <em>body</em> of the <code>main</code> function is declared with <code>{ }</code>, and represents its <em>scope</em>. Inside the body of <code>main</code>, we have <code>println!(&quot;Hello, world!&quot;);</code>. This looks like a function, but in fact is a <em>macro</em>. In Rust <em>macros</em> are denoted by the <code>!</code> at the end of a keyword.</p>
<p>There is no great parallel for <em>macros</em> in JavaScript, but a simple definition is that <em>macros</em> are code that generate other code when the program is compiled. Rust will replace <code>println!</code> with code for printing to <em>standard out</em> that works for whatever computer architecture you're compiling the Rust code for. In my case this would be code for printing in macOS, but it might be different for you.</p>
<p>With the basic setup and syntax tour out of the way, we can move on to an overview of our <code>miniwc</code> program.</p>
<p><em><code>cargo</code> isn't strictly necessary to create Rust binaries, it just provides some convenient tools and a bit of boilerplate to get you started. All you need to compile Rust projects is the Rust Compiler (<code>rustc</code>). Running <code>rustc foobar.rs</code> on any valid and correct Rust program will output an executable binary. Don't believe me? Try it with the code above!</em></p>
<h2 id="the-miniwc-program">The <code>miniwc</code> program</h2>
<p>At the end of this article, we will have an executable program that takes a filename as an argument and returns the word count of that document. We will explore the following concepts:</p>
<ul>
<li>Functions</li>
<li>Conditionals</li>
<li>Loops</li>
<li><code>struct</code></li>
<li>Traits and <code>impl</code></li>
<li>The <code>std</code> library</li>
<li><code>std::env</code></li>
<li><code>std::fs</code></li>
</ul>
<p>Let's get into it.</p>
<h3 id="building-a-foundation">Building a foundation</h3>
<p>Before we can begin tackling the program requirements we've outlined above, there are several Rust concepts that we need to anchor to their counterparts in JavaScript. <a href="https://blog.usejournal.com/you-probably-shouldt-be-using-react-2f45ca487c8e?source=friends_link&amp;sk=b88d7e3f0c715965bbc859b5ce8053e1">I'm a big advocate for understanding bedrock concepts</a>, especially as you move past the beginner stage where you know how to get things done, but maybe not why you're doing them that way. I feel that Rust is a great tool to put the effort in and <em>really</em> learn, so before we go ahead and actually write the code for our program, we're going to explore a prelude of necessary concepts, step by step. These include:</p>
<ul>
<li>The type system in Rust, and how it relates to types in JavaScript</li>
<li>Rust <code>struct</code>s, their similarity to JavaScript <code>Objects</code>, and an overview on how to use them to provide <em>structure</em> to our code</li>
<li>Rust <code>impl</code>s, the JavaScript <em>Prototypal Inheritance</em> model, and how we can create reusable functionality in our Rust code</li>
</ul>
<p>There are some concepts here that may seem very foreign, but they all map to JavaScript concepts you probably already know and use regularly. If you have a good grasp on the above topics already, feel free to skip the next few sections. Otherwise, let's unpack them one at a time.</p>
<h4 id="types">Types</h4>
<p>Rust is a <em>statically typed language</em>, and therefore it expects explicit <em>type</em> annotations in the places in your code where it isn't obvious what the type of a value is. If you have experience with TypeScript, this concept should be familiar.</p>
<p>Two common ways you'll interact with <em>types</em> in Rust is through argument types and return types:</p>
<pre style="background-color:#ffffff;">
<span style="color:#202020;">fn example_function(
  integer_arg: i64,
  string_arg: String,
  other_arg: OurCustomType ) -&gt; String {
    </span><span style="color:#bbbbbb;">// ---snip---
</span><span style="color:#202020;">}
</span></pre>
<p>In the above example, we pass three arguments to our <code>example_function</code>, <code>integer_arg</code> with the type <code>i64</code> (a 64-bit signed integer), <code>string_arg</code> with the type <code>String</code>, and <code>other_arg</code> with the made-up example type <code>OurCustomType</code>. These type annotations are denoted by the colon (<code>:</code>) following the argument name. After the list of arguments, there's an arrow (<code>-&gt;</code>) followed by <code>String</code> which signifies that this function will return a <code>String</code> value.</p>
<p>JavaScript is a dynamically typed language, which means all of the <em>type</em> behavior we have to specifically define in our Rust code is handled under the hood by the JavaScript runtime. JavaScript has primitive types like <code>Number</code> and <code>String</code>, but it doesn't require the programmer to be explicit about what <em>types</em> correspond to each value. JavaScript also doesn't allow the programmer to come up with their own types, like the <code>Args</code> type we saw previously in the <code>args</code> function signature. <a href="https://hackernoon.com/statically-typed-vs-dynamically-typed-languages-e4778e1ca55">This is both powerful and limiting</a>, depending on the context and use-case.</p>
<h4 id="structures-struct">Structures (<code>struct</code>)</h4>
<p>With the basics of <em>types</em> in Rust under our belts, let's take a moment to unwrap another fundamental Rust concept that we'll need going forward: <code>struct</code>. Rust, unlike modern JavaScript, has no concept of <code>class</code> and it doesn't have a catch-all, ubiquitous name/value collection like JavaScript's <code>Object</code> type. Instead, Rust allows you to associate fields and related functions using <em>structures</em>, via the keyword <code>struct</code>. This is somewhat similar to how <code>objects</code> are used in JavaScript. Compare the following two examples:</p>
<pre style="background-color:#ffffff;">
<span style="color:#202020;">let message = {
  title: </span><span style="color:#707070;">&quot;Message title&quot;
  </span><span style="color:#202020;">body: </span><span style="color:#707070;">&quot;This is a message.&quot;
</span><span style="color:#202020;">}
</span></pre><pre style="background-color:#ffffff;">
<span style="color:#202020;">struct Message {
  title: String,
  body: String
}

let message = Message {
  title: String::from(</span><span style="color:#707070;">&quot;Message title&quot;</span><span style="color:#202020;">),
  body: String::from(</span><span style="color:#707070;">&quot;This is a message.&quot;</span><span style="color:#202020;">)
}
</span></pre>
<p>Since Rust doesn't give you an arbitrary bucket of key/value pairs to work with (like JavaScript does with <code>Objects</code>), we first need to define the <em>structure</em> of our <code>Message</code> type, via the <code>struct</code> keyword. Note how in the JavaScript example, we just assign <code>String</code> values to the <code>message</code> and <code>body</code> keys. This is a very common pattern, and in some cases is extremely powerful and simple. In the Rust example, we have to be explicit about the types of values each <em>field</em> (note that in Rust, <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#defining-and-instantiating-structs">we call these key/value pairs <em>fields</em></a>, while in JavaScript they're called <em>properties</em>). Once we've told the Rust compiler what our <code>Message</code> <em>fields</em> will contain, we then can create a new <code>Message</code> with our specific field values.</p>
<h4 id="implementations-impl">Implementations (<code>impl</code>)</h4>
<p>JavaScript uses an inheritance model called <em>Prototypal Inheritance</em> in order to allow for extending and reusing behavior in your code. Another familiar model that accomplishes something similar is the more traditional class-based model you may have come across in other languages like Java and TypeScript (JavaScript has <code>class</code> syntax, but it's just sugar over its prototypal inheritance model).</p>
<p>For the purposes of this project, you don't need to be super familiar with the ins and outs of <em>Prototypal Inheritance</em> or <em>Object Oriented Programming</em>, but if you're interested in diving in, Mozilla offers an in-depth treatment <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">here</a>. What we're specifically interested in is how JavaScript allows you to implement and reuse behavior, versus how Rust does it. Consider the following JavaScript example:</p>
<pre style="background-color:#ffffff;">
<span style="color:#bbbbbb;">// Using JavaScript&#39;s `class` syntax because
// it&#39;s simpler for this example
</span><span style="color:#202020;">class Message {
  send(content) {
    console.log(content)
  }
}

class PrivateMessage extends Message {
  send(content) {
    super.send(</span><span style="color:#707070;">&#39;private: &#39; </span><span style="color:#202020;">+ content)
  }
}

var message = new Message()
message.send(</span><span style="color:#707070;">&#39;hello&#39;</span><span style="color:#202020;">) </span><span style="color:#bbbbbb;">// hello

</span><span style="color:#202020;">var privateMessage = new PrivateMessage()
privateMessage.send(</span><span style="color:#707070;">&#39;hello&#39;</span><span style="color:#202020;">) </span><span style="color:#bbbbbb;">// private: hello
</span></pre>
<p>Here, we've modeled <code>PrivateMessage</code> <em>as a</em> <code>Message</code>. It inherits the <code>send</code> function we defined on <code>Message</code>, but we can change it to be specific for our <code>PrivateMessage</code> class. Rust has a different way of doing things. Let's take a look at the same idea, expressed in Rust:</p>
<pre style="background-color:#ffffff;">
<span style="color:#202020;">struct PrivateMessage {}
struct NormalMessage {}

pub trait Message {
    fn send(&amp;self, content: &amp;str) {
        println!(</span><span style="color:#707070;">&quot;{}&quot;</span><span style="color:#202020;">, content);
    }
}

impl Message for NormalMessage {} </span><span style="color:#bbbbbb;">// Use the default `send`

</span><span style="color:#202020;">impl Message for PrivateMessage {
    fn send(&amp;self, content: &amp;str) {
        println!(</span><span style="color:#707070;">&quot;private: {}&quot;</span><span style="color:#202020;">, content);
    }
}

pub fn main() {
  let message = NormalMessage {};
  message.send(</span><span style="color:#707070;">&quot;hello&quot;</span><span style="color:#202020;">); </span><span style="color:#bbbbbb;">// hello

  </span><span style="color:#202020;">let private_message = PrivateMessage {};
  private_message.send(</span><span style="color:#707070;">&quot;hello&quot;</span><span style="color:#202020;">); </span><span style="color:#bbbbbb;">// private: hello
</span><span style="color:#202020;">}
</span></pre>
<p>In this version of the program, we've defined <code>Message</code> as a <em>trait</em>, which can be <em>implemented</em> by our other code. In other words, our <code>PrivateMessage</code> and <code>NormalMessage</code> structs<code>NormalMessage</code> uses the default <code>send</code> implementation that we define in the <code>Message</code> trait, while <code>PrivateMessage</code> implements its own version of <code>send</code>.</p>
<p>Hopefully this sheds a bit of light onto the basics of Rust inheritance (via <code>traits</code> and <code>impl</code>) versus JavaScript (via prototypes). If any of this still feels opaque, take some time to dive-in to the relevant sections in the Rust Book:</p>
<h3 id="handling-arguments">Handling arguments</h3>
<p>Now that we've explored the necessary foundational concepts to understand and implement our <code>miniwc</code> program, let's get back to our <code>miniwc</code> program. As mentioned before, our program should:</p>
<ul>
<li>Be executable</li>
<li>Take a filename as an argument</li>
<li>Return the word count of that document</li>
</ul>
<p>Currently, our program does none of the things outlined above. When you execute <code>cargo run</code> from the command line, we still just see <code>Hello, world!</code> printed out. Let's take it step by step, and first handle taking a filename as an argument.</p>
<p>In <code>node</code>, one of the global variables made available to our programs during runtime is the <code>process.argv</code> variable. This variable contains all of the arguments passed to your <code>node</code> program. Rust does not have a runtime, so how can we get arguments passed to our program?</p>
<p>Although Rust doesn't have a language-specific runtime, the operating system your Rust program runs on <em>is</em> technically a runtime. And luckily for us, the operating system provides a way to inject variables into programs. We won't need to get into the specifics of how that happens (and the potential pitfalls), because the <em>Rust standard library</em> provides an easy way for us to access the arguments passed to our program, via the <code>std::env</code> module. Similar to how <code>process.argv</code> works in <code>node</code>, the <code>std::env</code> module will allow us to get a list of arguments we can then use how we'd like.</p>
<p>In order to use the <code>std::env</code> module, we'll have to <code>use</code> it at the top of our program like so: <code>use std::env</code>. The <code>use</code> keyword in Rust is sort of analogous to the <code>import</code> keyword in ES6, and it allows us to bring a module into scope. With the <code>env</code> module in scope, we can now use the public function <a href="https://doc.rust-lang.org/std/env/fn.args.html"><code>args</code></a>, which exists in the <code>env</code> module.</p>
<p>This function will return a value with the <em>type</em> of <code>Args</code>, which <em>implements</em> the <em>trait</em> <code>Iterator</code>. The function signature for <code>args</code> looks like so: <code>fn args() -&gt; Args</code>.</p>
<p>These are all concepts we've explored in the last few sections, so now let's put them to work. Once you've added the <code>use</code> statement for <code>std::env</code>, your program should look like this:</p>
<p>Filename: src/main.rs</p>
<pre style="background-color:#ffffff;">
<span style="color:#202020;">use std::env;

fn main() {
    println!(</span><span style="color:#707070;">&quot;Hello, world!&quot;</span><span style="color:#202020;">);
}
</span></pre><h4 id="the-iterator-trait">The Iterator trait</h4>
<h4 id="storing-things-in-vectors">Storing things in Vectors</h4>
<h4 id="the-panic-macro">The <code>panic!</code> macro</h4>
<h3 id="the-filesystem">The filesystem</h3>
<h4 id="handling-possible-failure-with-expect">Handling possible failure with <code>expect</code></h4>

  </section>
<script src="/livereload.js?port=1024&mindelay=10"></script></body>

</html>